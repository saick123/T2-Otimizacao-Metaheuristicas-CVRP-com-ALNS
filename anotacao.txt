def worst_removal(solution: list[list[int]], q: int):
    
    r_costs = []
    D = []
    
    for route_idx, route in enumerate(solution):
        for c_idx, c in enumerate(route):
            r_cost = removal_cost(route, c, c_idx)
            r_costs.append([c, route_idx, r_cost])

    r_costs.sort(key=lambda x: x[-1], reverse=True)
    q_ = q
    p = 3 # qual tm que
    
    while q_:
        y = random.random()
        idx = math.floor(len(r_costs)*(math.pow(y, p)))
        
        client, route_idx, r_cost = r_costs.pop(idx)
        
        D.append(client)
        solution[route_idx].remove(client)
        q_ -=1
    
    return 



 if xt_cost < self.best_cost or random.random() < math.exp( (x_cost - xt_cost) / current_temp):
    x_solution, x_cost = copy.deepcopy(xt_solution), xt_cost
    
    if xt_cost < self.best_cost:
        self.best_solution, self.best_cost = copy.deepcopy(xt_solution), xt_cost
        costs.append(self.best_cost)    
        

                    
